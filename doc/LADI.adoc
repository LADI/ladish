LADI is a long term project to improve desktop integration and user workflow of Linux audio system based on  JACK.
History

By the end of 2007, it was evident that while JACK was a great system for connection audio applications, it had some drawbacks from the point of view of user workflow. The “jackd” command was (and still is) an executable used to start the JACK server. It is a per-user service, as opposed to most UNIX daemons that are system wide. As such, people tend to put it into the more known categories of "application" and "system daemon". However, the JACK server falls somewhere in between.

The application approach requires that the user manually starts the JACK server. This approach is used by applications such as  QJackCtl. However, some users, especially ones preferring the command line, tend to launch the JACK server by starting jack manually via the jackd command.

The system daemon approach suggests that the JACK server starts when it is first needed (e.g. on boot or login), and similarly terminates when it is not needed anymore (e.g. on shutdown or logout). To emulate this system daemon behavior, QJackCtl binds the JACK server instance lifetime to QJackCtl instance lifetime. Likewise, some Linux distributions provide init.d scripts. Other examples of the "system daemon" approach are the autolaunch functionality (i.e. start the JACK server when first application creates a jack client), and the "temporary" option of JACK server (i.e. close the JACK server once all clients have closed their connections).

The QJackCtl application was (and still is) by far the most popular approach for managing the JACK server. However, it too is subject to various issues stemming from the fact that the JACK server is not quite an application nor a system daemon, and has no specific way to be controlled:

+ If started by QJackCtl, the JACK server running as jackd provides log messages to its stdout/stderr that are captured by QJackCtl and displayed in a messages window. However, if jackd was started through the autolaunching mechanism, jackd outputs log messages to the stdout/stderr of the process that started jackd. If the processes is a GUI application, this typically means that the user is unable to view the log messages of the JACK server, and instead can only watch the JACK server status in the QJackCtl window via its tray icon, which does not provide any details. Originally, the only way available for applications like QJackCtl to control the JACK server was through libjack, the same library used by regular audio and MIDI processing applications. Unfortunately, this approach has some drawbacks. First, the logic and thus coding of the control application is complicated by the fact that it must interact with JACK under realtime constraints. Also, using libjack for control applications complicates the creation of control applications in high level interpreted languages like Python, due to the same realtime performance constraints of the JACK server. Finally, due to a bug in previous versions of the JACK server, jackd could decide to mistakenly detach some processes attached to itself. Quite often, the process mistakenly detached happened to be a control application like QJackCtl or  Patchage. This could be a real problem, given the fact that often the control application that was being killed by the “jack-killing-the-control-application bug” was supposed to restart the JACK server if it crashed!

+ QJackCtl, as a control application that can configure the JACK server, is dependent on the jackd command line options that are available at the time QJackCtl is released. Thus, each QJackCtl version is bound to a specific JACK server version. Unfortunately, they are for the most part developed independently, allowing distribution-provided versions of the packages to be easily mismatched. When the new JACK driver appeared (e.g. the FFADO driver used for FireWire? devices), QJackCtl had to add new UI elements for its configuration. Another problem with relying on command line options is that two incarnations of the JACK server exist, jack1 and jack2 (formerly known as jackdmp). While they share some command line options, there are also options unique to each. Thus, a QJackCtl user may be able to tweak GUI options that at best have no effect, and at worst cause jackd to fail due to unknown options.

+ Two places are commonly used to store JACK server settings: the ~/.jackdrc file that is used by the libjack autolaunching mechanism, and the QJackCtl internal settings storage that can be transformed into ~/.jackdrc content. However, ~/.jackdrc is not really a settings file, but instead a script that starts the JACK server. It is then incorrectly used to start QJackCtl that in turn starts jackd.

While most of these issues can be handled by more experienced users, they show that the current methods for interacting with the JACK server could benefit from a new approach, such as one based on an advanced session handler. This advanced session handler would apply the common software principle of separation, with components of a session connected by an external application (i.e. the control application), but remaining independent from each other. Thus, if one component of the session crashes, it would not effect other components in the session. In this scenario, both the JACK server and JACK clients could be restarted and the whole session reconstructed with some technical skill applied.

A first step towards fixing these limitations is “jackdbus”, created by Nedko Arnaudov. It is an executable command that works as alternative to jackd, as it can also start the JACK server. However, there are some important differences. The well known and general purpose  IPC mechanism (D-Bus) is used for communication between control applications and the JACK server. This ensures that control applications can be implemented much easier because they can be implemented in a few lines of an interpreted language like Python. Also, because control applications are no longer regular JACK clients, they are unknown to the JACK server itself and thus are not subject to the same realtime performance restrictions of regular JACK client applications. Control applications based on D-Bus can also share some high-level information among JACK clients. For example, when the number of XRUNS are cleared in one application, all applications in the session can clear their XRUN count as well. Also, D-Bus provides a mechanism to start a service when it is first accessed. This functionality is used to make jackdbus behave like a real daemon (i.e. a process that runs in background and has log file). D-Bus allows both session bound functionality through the session bus (usually this means per user login) and system-wide functionality for daemons that are used by more than one user. jackdbus makes use of the D-Bus session bus.

Juuso Alasuutari and Marc-Olivier Barre joined Nedko Arnaudov`s efforts in improving control application support for the JACK server, with Juuso helping with the jackdbus application itself, and Marc creating a suite of small Python GUI tools for use with jackdbus. This suite was initially called pyjackctl, but was later renamed to  LADI Tools. Later, Krzysztof Foltman stepped in and provided great improvements to ladiconf, a JACK server configuration application from the LADI tools package.

At  LAC 2008, there was a meeting that discussed the future of the jackdbus LADI improvements. There, it was decided to integrate jackdbus into jack2 through a special new Control API. As a result, in May 2008, jackdbus was merged into the jack2 mainline and is included in the 1.90 and later releases of jack2.
jackdbus status

jackdbus for jack1 exists but is not accepted upstream for various reasons. However, it can be downloaded from  here. the jack1 version of jackdbus is less used and thus less tested mainly because of decreasing motivation to improve it because of upstream rejections.

jackdbus for jack2 is bundled in jack2 itself and can be enabled with the --dbus option at the configure stage.
ladish

LADI Session Handler is a rewrite of LASH.
